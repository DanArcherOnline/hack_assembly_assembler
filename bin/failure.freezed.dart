// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FailureTearOff {
  const _$FailureTearOff();

  NotInstructionFailure notInstruction() {
    return const NotInstructionFailure();
  }

  ValueTooLargeFailure valueTooLarge() {
    return const ValueTooLargeFailure();
  }

  InvalidAInstructionValueFailure invalidAInstructionValue() {
    return const InvalidAInstructionValueFailure();
  }

  InvalidCInstructionDestinationFailure invalidCInstructionDestination() {
    return const InvalidCInstructionDestinationFailure();
  }

  InvalidCInstructionComputationFailure invalidCInstructionComputation() {
    return const InvalidCInstructionComputationFailure();
  }

  InvalidCInstructionJumpFailure invalidCInstructionJump() {
    return const InvalidCInstructionJumpFailure();
  }

  InvalidFilePathFailure InvalidFilePath() {
    return const InvalidFilePathFailure();
  }

  SymbolDoesNotExistFailure symbolDoesNotExist() {
    return const SymbolDoesNotExistFailure();
  }
}

/// @nodoc
const $Failure = _$FailureTearOff();

/// @nodoc
mixin _$Failure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
    required TResult Function() InvalidFilePath,
    required TResult Function() symbolDoesNotExist,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(SymbolDoesNotExistFailure value)
        symbolDoesNotExist,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FailureCopyWith<$Res> {
  factory $FailureCopyWith(Failure value, $Res Function(Failure) then) =
      _$FailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$FailureCopyWithImpl<$Res> implements $FailureCopyWith<$Res> {
  _$FailureCopyWithImpl(this._value, this._then);

  final Failure _value;
  // ignore: unused_field
  final $Res Function(Failure) _then;
}

/// @nodoc
abstract class $NotInstructionFailureCopyWith<$Res> {
  factory $NotInstructionFailureCopyWith(NotInstructionFailure value,
          $Res Function(NotInstructionFailure) then) =
      _$NotInstructionFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$NotInstructionFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $NotInstructionFailureCopyWith<$Res> {
  _$NotInstructionFailureCopyWithImpl(
      NotInstructionFailure _value, $Res Function(NotInstructionFailure) _then)
      : super(_value, (v) => _then(v as NotInstructionFailure));

  @override
  NotInstructionFailure get _value => super._value as NotInstructionFailure;
}

/// @nodoc

class _$NotInstructionFailure implements NotInstructionFailure {
  const _$NotInstructionFailure();

  @override
  String toString() {
    return 'Failure.notInstruction()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NotInstructionFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
    required TResult Function() InvalidFilePath,
    required TResult Function() symbolDoesNotExist,
  }) {
    return notInstruction();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
  }) {
    return notInstruction?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (notInstruction != null) {
      return notInstruction();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(SymbolDoesNotExistFailure value)
        symbolDoesNotExist,
  }) {
    return notInstruction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
  }) {
    return notInstruction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (notInstruction != null) {
      return notInstruction(this);
    }
    return orElse();
  }
}

abstract class NotInstructionFailure implements Failure {
  const factory NotInstructionFailure() = _$NotInstructionFailure;
}

/// @nodoc
abstract class $ValueTooLargeFailureCopyWith<$Res> {
  factory $ValueTooLargeFailureCopyWith(ValueTooLargeFailure value,
          $Res Function(ValueTooLargeFailure) then) =
      _$ValueTooLargeFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$ValueTooLargeFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $ValueTooLargeFailureCopyWith<$Res> {
  _$ValueTooLargeFailureCopyWithImpl(
      ValueTooLargeFailure _value, $Res Function(ValueTooLargeFailure) _then)
      : super(_value, (v) => _then(v as ValueTooLargeFailure));

  @override
  ValueTooLargeFailure get _value => super._value as ValueTooLargeFailure;
}

/// @nodoc

class _$ValueTooLargeFailure implements ValueTooLargeFailure {
  const _$ValueTooLargeFailure();

  @override
  String toString() {
    return 'Failure.valueTooLarge()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ValueTooLargeFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
    required TResult Function() InvalidFilePath,
    required TResult Function() symbolDoesNotExist,
  }) {
    return valueTooLarge();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
  }) {
    return valueTooLarge?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (valueTooLarge != null) {
      return valueTooLarge();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(SymbolDoesNotExistFailure value)
        symbolDoesNotExist,
  }) {
    return valueTooLarge(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
  }) {
    return valueTooLarge?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (valueTooLarge != null) {
      return valueTooLarge(this);
    }
    return orElse();
  }
}

abstract class ValueTooLargeFailure implements Failure {
  const factory ValueTooLargeFailure() = _$ValueTooLargeFailure;
}

/// @nodoc
abstract class $InvalidAInstructionValueFailureCopyWith<$Res> {
  factory $InvalidAInstructionValueFailureCopyWith(
          InvalidAInstructionValueFailure value,
          $Res Function(InvalidAInstructionValueFailure) then) =
      _$InvalidAInstructionValueFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidAInstructionValueFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidAInstructionValueFailureCopyWith<$Res> {
  _$InvalidAInstructionValueFailureCopyWithImpl(
      InvalidAInstructionValueFailure _value,
      $Res Function(InvalidAInstructionValueFailure) _then)
      : super(_value, (v) => _then(v as InvalidAInstructionValueFailure));

  @override
  InvalidAInstructionValueFailure get _value =>
      super._value as InvalidAInstructionValueFailure;
}

/// @nodoc

class _$InvalidAInstructionValueFailure
    implements InvalidAInstructionValueFailure {
  const _$InvalidAInstructionValueFailure();

  @override
  String toString() {
    return 'Failure.invalidAInstructionValue()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidAInstructionValueFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
    required TResult Function() InvalidFilePath,
    required TResult Function() symbolDoesNotExist,
  }) {
    return invalidAInstructionValue();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
  }) {
    return invalidAInstructionValue?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (invalidAInstructionValue != null) {
      return invalidAInstructionValue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(SymbolDoesNotExistFailure value)
        symbolDoesNotExist,
  }) {
    return invalidAInstructionValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
  }) {
    return invalidAInstructionValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (invalidAInstructionValue != null) {
      return invalidAInstructionValue(this);
    }
    return orElse();
  }
}

abstract class InvalidAInstructionValueFailure implements Failure {
  const factory InvalidAInstructionValueFailure() =
      _$InvalidAInstructionValueFailure;
}

/// @nodoc
abstract class $InvalidCInstructionDestinationFailureCopyWith<$Res> {
  factory $InvalidCInstructionDestinationFailureCopyWith(
          InvalidCInstructionDestinationFailure value,
          $Res Function(InvalidCInstructionDestinationFailure) then) =
      _$InvalidCInstructionDestinationFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidCInstructionDestinationFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidCInstructionDestinationFailureCopyWith<$Res> {
  _$InvalidCInstructionDestinationFailureCopyWithImpl(
      InvalidCInstructionDestinationFailure _value,
      $Res Function(InvalidCInstructionDestinationFailure) _then)
      : super(_value, (v) => _then(v as InvalidCInstructionDestinationFailure));

  @override
  InvalidCInstructionDestinationFailure get _value =>
      super._value as InvalidCInstructionDestinationFailure;
}

/// @nodoc

class _$InvalidCInstructionDestinationFailure
    implements InvalidCInstructionDestinationFailure {
  const _$InvalidCInstructionDestinationFailure();

  @override
  String toString() {
    return 'Failure.invalidCInstructionDestination()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidCInstructionDestinationFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
    required TResult Function() InvalidFilePath,
    required TResult Function() symbolDoesNotExist,
  }) {
    return invalidCInstructionDestination();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
  }) {
    return invalidCInstructionDestination?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (invalidCInstructionDestination != null) {
      return invalidCInstructionDestination();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(SymbolDoesNotExistFailure value)
        symbolDoesNotExist,
  }) {
    return invalidCInstructionDestination(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
  }) {
    return invalidCInstructionDestination?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (invalidCInstructionDestination != null) {
      return invalidCInstructionDestination(this);
    }
    return orElse();
  }
}

abstract class InvalidCInstructionDestinationFailure implements Failure {
  const factory InvalidCInstructionDestinationFailure() =
      _$InvalidCInstructionDestinationFailure;
}

/// @nodoc
abstract class $InvalidCInstructionComputationFailureCopyWith<$Res> {
  factory $InvalidCInstructionComputationFailureCopyWith(
          InvalidCInstructionComputationFailure value,
          $Res Function(InvalidCInstructionComputationFailure) then) =
      _$InvalidCInstructionComputationFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidCInstructionComputationFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidCInstructionComputationFailureCopyWith<$Res> {
  _$InvalidCInstructionComputationFailureCopyWithImpl(
      InvalidCInstructionComputationFailure _value,
      $Res Function(InvalidCInstructionComputationFailure) _then)
      : super(_value, (v) => _then(v as InvalidCInstructionComputationFailure));

  @override
  InvalidCInstructionComputationFailure get _value =>
      super._value as InvalidCInstructionComputationFailure;
}

/// @nodoc

class _$InvalidCInstructionComputationFailure
    implements InvalidCInstructionComputationFailure {
  const _$InvalidCInstructionComputationFailure();

  @override
  String toString() {
    return 'Failure.invalidCInstructionComputation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidCInstructionComputationFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
    required TResult Function() InvalidFilePath,
    required TResult Function() symbolDoesNotExist,
  }) {
    return invalidCInstructionComputation();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
  }) {
    return invalidCInstructionComputation?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (invalidCInstructionComputation != null) {
      return invalidCInstructionComputation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(SymbolDoesNotExistFailure value)
        symbolDoesNotExist,
  }) {
    return invalidCInstructionComputation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
  }) {
    return invalidCInstructionComputation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (invalidCInstructionComputation != null) {
      return invalidCInstructionComputation(this);
    }
    return orElse();
  }
}

abstract class InvalidCInstructionComputationFailure implements Failure {
  const factory InvalidCInstructionComputationFailure() =
      _$InvalidCInstructionComputationFailure;
}

/// @nodoc
abstract class $InvalidCInstructionJumpFailureCopyWith<$Res> {
  factory $InvalidCInstructionJumpFailureCopyWith(
          InvalidCInstructionJumpFailure value,
          $Res Function(InvalidCInstructionJumpFailure) then) =
      _$InvalidCInstructionJumpFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidCInstructionJumpFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidCInstructionJumpFailureCopyWith<$Res> {
  _$InvalidCInstructionJumpFailureCopyWithImpl(
      InvalidCInstructionJumpFailure _value,
      $Res Function(InvalidCInstructionJumpFailure) _then)
      : super(_value, (v) => _then(v as InvalidCInstructionJumpFailure));

  @override
  InvalidCInstructionJumpFailure get _value =>
      super._value as InvalidCInstructionJumpFailure;
}

/// @nodoc

class _$InvalidCInstructionJumpFailure
    implements InvalidCInstructionJumpFailure {
  const _$InvalidCInstructionJumpFailure();

  @override
  String toString() {
    return 'Failure.invalidCInstructionJump()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidCInstructionJumpFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
    required TResult Function() InvalidFilePath,
    required TResult Function() symbolDoesNotExist,
  }) {
    return invalidCInstructionJump();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
  }) {
    return invalidCInstructionJump?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (invalidCInstructionJump != null) {
      return invalidCInstructionJump();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(SymbolDoesNotExistFailure value)
        symbolDoesNotExist,
  }) {
    return invalidCInstructionJump(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
  }) {
    return invalidCInstructionJump?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (invalidCInstructionJump != null) {
      return invalidCInstructionJump(this);
    }
    return orElse();
  }
}

abstract class InvalidCInstructionJumpFailure implements Failure {
  const factory InvalidCInstructionJumpFailure() =
      _$InvalidCInstructionJumpFailure;
}

/// @nodoc
abstract class $InvalidFilePathFailureCopyWith<$Res> {
  factory $InvalidFilePathFailureCopyWith(InvalidFilePathFailure value,
          $Res Function(InvalidFilePathFailure) then) =
      _$InvalidFilePathFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidFilePathFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidFilePathFailureCopyWith<$Res> {
  _$InvalidFilePathFailureCopyWithImpl(InvalidFilePathFailure _value,
      $Res Function(InvalidFilePathFailure) _then)
      : super(_value, (v) => _then(v as InvalidFilePathFailure));

  @override
  InvalidFilePathFailure get _value => super._value as InvalidFilePathFailure;
}

/// @nodoc

class _$InvalidFilePathFailure implements InvalidFilePathFailure {
  const _$InvalidFilePathFailure();

  @override
  String toString() {
    return 'Failure.InvalidFilePath()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidFilePathFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
    required TResult Function() InvalidFilePath,
    required TResult Function() symbolDoesNotExist,
  }) {
    return InvalidFilePath();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
  }) {
    return InvalidFilePath?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (InvalidFilePath != null) {
      return InvalidFilePath();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(SymbolDoesNotExistFailure value)
        symbolDoesNotExist,
  }) {
    return InvalidFilePath(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
  }) {
    return InvalidFilePath?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (InvalidFilePath != null) {
      return InvalidFilePath(this);
    }
    return orElse();
  }
}

abstract class InvalidFilePathFailure implements Failure {
  const factory InvalidFilePathFailure() = _$InvalidFilePathFailure;
}

/// @nodoc
abstract class $SymbolDoesNotExistFailureCopyWith<$Res> {
  factory $SymbolDoesNotExistFailureCopyWith(SymbolDoesNotExistFailure value,
          $Res Function(SymbolDoesNotExistFailure) then) =
      _$SymbolDoesNotExistFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$SymbolDoesNotExistFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $SymbolDoesNotExistFailureCopyWith<$Res> {
  _$SymbolDoesNotExistFailureCopyWithImpl(SymbolDoesNotExistFailure _value,
      $Res Function(SymbolDoesNotExistFailure) _then)
      : super(_value, (v) => _then(v as SymbolDoesNotExistFailure));

  @override
  SymbolDoesNotExistFailure get _value =>
      super._value as SymbolDoesNotExistFailure;
}

/// @nodoc

class _$SymbolDoesNotExistFailure implements SymbolDoesNotExistFailure {
  const _$SymbolDoesNotExistFailure();

  @override
  String toString() {
    return 'Failure.symbolDoesNotExist()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SymbolDoesNotExistFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
    required TResult Function() InvalidFilePath,
    required TResult Function() symbolDoesNotExist,
  }) {
    return symbolDoesNotExist();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
  }) {
    return symbolDoesNotExist?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    TResult Function()? InvalidFilePath,
    TResult Function()? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (symbolDoesNotExist != null) {
      return symbolDoesNotExist();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(SymbolDoesNotExistFailure value)
        symbolDoesNotExist,
  }) {
    return symbolDoesNotExist(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
  }) {
    return symbolDoesNotExist?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(SymbolDoesNotExistFailure value)? symbolDoesNotExist,
    required TResult orElse(),
  }) {
    if (symbolDoesNotExist != null) {
      return symbolDoesNotExist(this);
    }
    return orElse();
  }
}

abstract class SymbolDoesNotExistFailure implements Failure {
  const factory SymbolDoesNotExistFailure() = _$SymbolDoesNotExistFailure;
}
