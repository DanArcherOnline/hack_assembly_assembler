// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FailureTearOff {
  const _$FailureTearOff();

  NotInstructionFailure notInstruction() {
    return const NotInstructionFailure();
  }

  ValueTooLargeFailure valueTooLarge() {
    return const ValueTooLargeFailure();
  }

  InvalidAInstructionValueFailure invalidAInstructionValue() {
    return const InvalidAInstructionValueFailure();
  }

  InvalidCInstructionDestinationFailure invalidCInstructionDestination() {
    return const InvalidCInstructionDestinationFailure();
  }

  InvalidCInstructionComputationFailure invalidCInstructionComputation() {
    return const InvalidCInstructionComputationFailure();
  }

  InvalidCInstructionJumpFailure invalidCInstructionJump() {
    return const InvalidCInstructionJumpFailure();
  }
}

/// @nodoc
const $Failure = _$FailureTearOff();

/// @nodoc
mixin _$Failure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FailureCopyWith<$Res> {
  factory $FailureCopyWith(Failure value, $Res Function(Failure) then) =
      _$FailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$FailureCopyWithImpl<$Res> implements $FailureCopyWith<$Res> {
  _$FailureCopyWithImpl(this._value, this._then);

  final Failure _value;
  // ignore: unused_field
  final $Res Function(Failure) _then;
}

/// @nodoc
abstract class $NotInstructionFailureCopyWith<$Res> {
  factory $NotInstructionFailureCopyWith(NotInstructionFailure value,
          $Res Function(NotInstructionFailure) then) =
      _$NotInstructionFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$NotInstructionFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $NotInstructionFailureCopyWith<$Res> {
  _$NotInstructionFailureCopyWithImpl(
      NotInstructionFailure _value, $Res Function(NotInstructionFailure) _then)
      : super(_value, (v) => _then(v as NotInstructionFailure));

  @override
  NotInstructionFailure get _value => super._value as NotInstructionFailure;
}

/// @nodoc

class _$NotInstructionFailure implements NotInstructionFailure {
  const _$NotInstructionFailure();

  @override
  String toString() {
    return 'Failure.notInstruction()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NotInstructionFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
  }) {
    return notInstruction();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
  }) {
    return notInstruction?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    required TResult orElse(),
  }) {
    if (notInstruction != null) {
      return notInstruction();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
  }) {
    return notInstruction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
  }) {
    return notInstruction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    required TResult orElse(),
  }) {
    if (notInstruction != null) {
      return notInstruction(this);
    }
    return orElse();
  }
}

abstract class NotInstructionFailure implements Failure {
  const factory NotInstructionFailure() = _$NotInstructionFailure;
}

/// @nodoc
abstract class $ValueTooLargeFailureCopyWith<$Res> {
  factory $ValueTooLargeFailureCopyWith(ValueTooLargeFailure value,
          $Res Function(ValueTooLargeFailure) then) =
      _$ValueTooLargeFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$ValueTooLargeFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $ValueTooLargeFailureCopyWith<$Res> {
  _$ValueTooLargeFailureCopyWithImpl(
      ValueTooLargeFailure _value, $Res Function(ValueTooLargeFailure) _then)
      : super(_value, (v) => _then(v as ValueTooLargeFailure));

  @override
  ValueTooLargeFailure get _value => super._value as ValueTooLargeFailure;
}

/// @nodoc

class _$ValueTooLargeFailure implements ValueTooLargeFailure {
  const _$ValueTooLargeFailure();

  @override
  String toString() {
    return 'Failure.valueTooLarge()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ValueTooLargeFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
  }) {
    return valueTooLarge();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
  }) {
    return valueTooLarge?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    required TResult orElse(),
  }) {
    if (valueTooLarge != null) {
      return valueTooLarge();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
  }) {
    return valueTooLarge(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
  }) {
    return valueTooLarge?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    required TResult orElse(),
  }) {
    if (valueTooLarge != null) {
      return valueTooLarge(this);
    }
    return orElse();
  }
}

abstract class ValueTooLargeFailure implements Failure {
  const factory ValueTooLargeFailure() = _$ValueTooLargeFailure;
}

/// @nodoc
abstract class $InvalidAInstructionValueFailureCopyWith<$Res> {
  factory $InvalidAInstructionValueFailureCopyWith(
          InvalidAInstructionValueFailure value,
          $Res Function(InvalidAInstructionValueFailure) then) =
      _$InvalidAInstructionValueFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidAInstructionValueFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidAInstructionValueFailureCopyWith<$Res> {
  _$InvalidAInstructionValueFailureCopyWithImpl(
      InvalidAInstructionValueFailure _value,
      $Res Function(InvalidAInstructionValueFailure) _then)
      : super(_value, (v) => _then(v as InvalidAInstructionValueFailure));

  @override
  InvalidAInstructionValueFailure get _value =>
      super._value as InvalidAInstructionValueFailure;
}

/// @nodoc

class _$InvalidAInstructionValueFailure
    implements InvalidAInstructionValueFailure {
  const _$InvalidAInstructionValueFailure();

  @override
  String toString() {
    return 'Failure.invalidAInstructionValue()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidAInstructionValueFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
  }) {
    return invalidAInstructionValue();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
  }) {
    return invalidAInstructionValue?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    required TResult orElse(),
  }) {
    if (invalidAInstructionValue != null) {
      return invalidAInstructionValue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
  }) {
    return invalidAInstructionValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
  }) {
    return invalidAInstructionValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    required TResult orElse(),
  }) {
    if (invalidAInstructionValue != null) {
      return invalidAInstructionValue(this);
    }
    return orElse();
  }
}

abstract class InvalidAInstructionValueFailure implements Failure {
  const factory InvalidAInstructionValueFailure() =
      _$InvalidAInstructionValueFailure;
}

/// @nodoc
abstract class $InvalidCInstructionDestinationFailureCopyWith<$Res> {
  factory $InvalidCInstructionDestinationFailureCopyWith(
          InvalidCInstructionDestinationFailure value,
          $Res Function(InvalidCInstructionDestinationFailure) then) =
      _$InvalidCInstructionDestinationFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidCInstructionDestinationFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidCInstructionDestinationFailureCopyWith<$Res> {
  _$InvalidCInstructionDestinationFailureCopyWithImpl(
      InvalidCInstructionDestinationFailure _value,
      $Res Function(InvalidCInstructionDestinationFailure) _then)
      : super(_value, (v) => _then(v as InvalidCInstructionDestinationFailure));

  @override
  InvalidCInstructionDestinationFailure get _value =>
      super._value as InvalidCInstructionDestinationFailure;
}

/// @nodoc

class _$InvalidCInstructionDestinationFailure
    implements InvalidCInstructionDestinationFailure {
  const _$InvalidCInstructionDestinationFailure();

  @override
  String toString() {
    return 'Failure.invalidCInstructionDestination()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidCInstructionDestinationFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
  }) {
    return invalidCInstructionDestination();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
  }) {
    return invalidCInstructionDestination?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    required TResult orElse(),
  }) {
    if (invalidCInstructionDestination != null) {
      return invalidCInstructionDestination();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
  }) {
    return invalidCInstructionDestination(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
  }) {
    return invalidCInstructionDestination?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    required TResult orElse(),
  }) {
    if (invalidCInstructionDestination != null) {
      return invalidCInstructionDestination(this);
    }
    return orElse();
  }
}

abstract class InvalidCInstructionDestinationFailure implements Failure {
  const factory InvalidCInstructionDestinationFailure() =
      _$InvalidCInstructionDestinationFailure;
}

/// @nodoc
abstract class $InvalidCInstructionComputationFailureCopyWith<$Res> {
  factory $InvalidCInstructionComputationFailureCopyWith(
          InvalidCInstructionComputationFailure value,
          $Res Function(InvalidCInstructionComputationFailure) then) =
      _$InvalidCInstructionComputationFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidCInstructionComputationFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidCInstructionComputationFailureCopyWith<$Res> {
  _$InvalidCInstructionComputationFailureCopyWithImpl(
      InvalidCInstructionComputationFailure _value,
      $Res Function(InvalidCInstructionComputationFailure) _then)
      : super(_value, (v) => _then(v as InvalidCInstructionComputationFailure));

  @override
  InvalidCInstructionComputationFailure get _value =>
      super._value as InvalidCInstructionComputationFailure;
}

/// @nodoc

class _$InvalidCInstructionComputationFailure
    implements InvalidCInstructionComputationFailure {
  const _$InvalidCInstructionComputationFailure();

  @override
  String toString() {
    return 'Failure.invalidCInstructionComputation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidCInstructionComputationFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
  }) {
    return invalidCInstructionComputation();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
  }) {
    return invalidCInstructionComputation?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    required TResult orElse(),
  }) {
    if (invalidCInstructionComputation != null) {
      return invalidCInstructionComputation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
  }) {
    return invalidCInstructionComputation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
  }) {
    return invalidCInstructionComputation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    required TResult orElse(),
  }) {
    if (invalidCInstructionComputation != null) {
      return invalidCInstructionComputation(this);
    }
    return orElse();
  }
}

abstract class InvalidCInstructionComputationFailure implements Failure {
  const factory InvalidCInstructionComputationFailure() =
      _$InvalidCInstructionComputationFailure;
}

/// @nodoc
abstract class $InvalidCInstructionJumpFailureCopyWith<$Res> {
  factory $InvalidCInstructionJumpFailureCopyWith(
          InvalidCInstructionJumpFailure value,
          $Res Function(InvalidCInstructionJumpFailure) then) =
      _$InvalidCInstructionJumpFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidCInstructionJumpFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidCInstructionJumpFailureCopyWith<$Res> {
  _$InvalidCInstructionJumpFailureCopyWithImpl(
      InvalidCInstructionJumpFailure _value,
      $Res Function(InvalidCInstructionJumpFailure) _then)
      : super(_value, (v) => _then(v as InvalidCInstructionJumpFailure));

  @override
  InvalidCInstructionJumpFailure get _value =>
      super._value as InvalidCInstructionJumpFailure;
}

/// @nodoc

class _$InvalidCInstructionJumpFailure
    implements InvalidCInstructionJumpFailure {
  const _$InvalidCInstructionJumpFailure();

  @override
  String toString() {
    return 'Failure.invalidCInstructionJump()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidCInstructionJumpFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() notInstruction,
    required TResult Function() valueTooLarge,
    required TResult Function() invalidAInstructionValue,
    required TResult Function() invalidCInstructionDestination,
    required TResult Function() invalidCInstructionComputation,
    required TResult Function() invalidCInstructionJump,
  }) {
    return invalidCInstructionJump();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
  }) {
    return invalidCInstructionJump?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? notInstruction,
    TResult Function()? valueTooLarge,
    TResult Function()? invalidAInstructionValue,
    TResult Function()? invalidCInstructionDestination,
    TResult Function()? invalidCInstructionComputation,
    TResult Function()? invalidCInstructionJump,
    required TResult orElse(),
  }) {
    if (invalidCInstructionJump != null) {
      return invalidCInstructionJump();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(ValueTooLargeFailure value) valueTooLarge,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
  }) {
    return invalidCInstructionJump(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
  }) {
    return invalidCInstructionJump?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(ValueTooLargeFailure value)? valueTooLarge,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    required TResult orElse(),
  }) {
    if (invalidCInstructionJump != null) {
      return invalidCInstructionJump(this);
    }
    return orElse();
  }
}

abstract class InvalidCInstructionJumpFailure implements Failure {
  const factory InvalidCInstructionJumpFailure() =
      _$InvalidCInstructionJumpFailure;
}
