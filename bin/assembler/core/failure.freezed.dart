// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FailureTearOff {
  const _$FailureTearOff();

  NotInstructionFailure notInstruction(
      {required NotInstructionType type, int? lineNumber, String? line}) {
    return NotInstructionFailure(
      type: type,
      lineNumber: lineNumber,
      line: line,
    );
  }

  InvalidAInstructionValueFailure invalidAInstructionValue(
      {required InvalidAInstructionValueType type,
      int? lineNumber,
      String? line}) {
    return InvalidAInstructionValueFailure(
      type: type,
      lineNumber: lineNumber,
      line: line,
    );
  }

  InvalidCInstructionDestinationFailure invalidCInstructionDestination(
      {required InvalidCInstructionDestinationType type,
      int? lineNumber,
      String? line}) {
    return InvalidCInstructionDestinationFailure(
      type: type,
      lineNumber: lineNumber,
      line: line,
    );
  }

  InvalidCInstructionComputationFailure invalidCInstructionComputation(
      {required InvalidCInstructionComputationType type,
      int? lineNumber,
      String? line}) {
    return InvalidCInstructionComputationFailure(
      type: type,
      lineNumber: lineNumber,
      line: line,
    );
  }

  InvalidCInstructionJumpFailure invalidCInstructionJump(
      {required InvalidCInstructionJumpType type,
      int? lineNumber,
      String? line}) {
    return InvalidCInstructionJumpFailure(
      type: type,
      lineNumber: lineNumber,
      line: line,
    );
  }

  InvalidFilePathFailure InvalidFilePath(
      {required InvalidFilePathType type, int? lineNumber, String? line}) {
    return InvalidFilePathFailure(
      type: type,
      lineNumber: lineNumber,
      line: line,
    );
  }

  InvalidLabelFailure invalidLabel(
      {required InvalidLabelType type, int? lineNumber, String? line}) {
    return InvalidLabelFailure(
      type: type,
      lineNumber: lineNumber,
      line: line,
    );
  }
}

/// @nodoc
const $Failure = _$FailureTearOff();

/// @nodoc
mixin _$Failure {
  int? get lineNumber => throw _privateConstructorUsedError;
  String? get line => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            NotInstructionType type, int? lineNumber, String? line)
        notInstruction,
    required TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationType type,
            int? lineNumber, String? line)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationType type,
            int? lineNumber, String? line)
        invalidCInstructionComputation,
    required TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)
        invalidCInstructionJump,
    required TResult Function(
            InvalidFilePathType type, int? lineNumber, String? line)
        InvalidFilePath,
    required TResult Function(
            InvalidLabelType type, int? lineNumber, String? line)
        invalidLabel,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(InvalidLabelFailure value) invalidLabel,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FailureCopyWith<Failure> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FailureCopyWith<$Res> {
  factory $FailureCopyWith(Failure value, $Res Function(Failure) then) =
      _$FailureCopyWithImpl<$Res>;
  $Res call({int? lineNumber, String? line});
}

/// @nodoc
class _$FailureCopyWithImpl<$Res> implements $FailureCopyWith<$Res> {
  _$FailureCopyWithImpl(this._value, this._then);

  final Failure _value;
  // ignore: unused_field
  final $Res Function(Failure) _then;

  @override
  $Res call({
    Object? lineNumber = freezed,
    Object? line = freezed,
  }) {
    return _then(_value.copyWith(
      lineNumber: lineNumber == freezed
          ? _value.lineNumber
          : lineNumber // ignore: cast_nullable_to_non_nullable
              as int?,
      line: line == freezed
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class $NotInstructionFailureCopyWith<$Res>
    implements $FailureCopyWith<$Res> {
  factory $NotInstructionFailureCopyWith(NotInstructionFailure value,
          $Res Function(NotInstructionFailure) then) =
      _$NotInstructionFailureCopyWithImpl<$Res>;
  @override
  $Res call({NotInstructionType type, int? lineNumber, String? line});
}

/// @nodoc
class _$NotInstructionFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $NotInstructionFailureCopyWith<$Res> {
  _$NotInstructionFailureCopyWithImpl(
      NotInstructionFailure _value, $Res Function(NotInstructionFailure) _then)
      : super(_value, (v) => _then(v as NotInstructionFailure));

  @override
  NotInstructionFailure get _value => super._value as NotInstructionFailure;

  @override
  $Res call({
    Object? type = freezed,
    Object? lineNumber = freezed,
    Object? line = freezed,
  }) {
    return _then(NotInstructionFailure(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as NotInstructionType,
      lineNumber: lineNumber == freezed
          ? _value.lineNumber
          : lineNumber // ignore: cast_nullable_to_non_nullable
              as int?,
      line: line == freezed
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$NotInstructionFailure implements NotInstructionFailure {
  const _$NotInstructionFailure(
      {required this.type, this.lineNumber, this.line});

  @override
  final NotInstructionType type;
  @override
  final int? lineNumber;
  @override
  final String? line;

  @override
  String toString() {
    return 'Failure.notInstruction(type: $type, lineNumber: $lineNumber, line: $line)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NotInstructionFailure &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.lineNumber, lineNumber) ||
                const DeepCollectionEquality()
                    .equals(other.lineNumber, lineNumber)) &&
            (identical(other.line, line) ||
                const DeepCollectionEquality().equals(other.line, line)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(lineNumber) ^
      const DeepCollectionEquality().hash(line);

  @JsonKey(ignore: true)
  @override
  $NotInstructionFailureCopyWith<NotInstructionFailure> get copyWith =>
      _$NotInstructionFailureCopyWithImpl<NotInstructionFailure>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            NotInstructionType type, int? lineNumber, String? line)
        notInstruction,
    required TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationType type,
            int? lineNumber, String? line)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationType type,
            int? lineNumber, String? line)
        invalidCInstructionComputation,
    required TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)
        invalidCInstructionJump,
    required TResult Function(
            InvalidFilePathType type, int? lineNumber, String? line)
        InvalidFilePath,
    required TResult Function(
            InvalidLabelType type, int? lineNumber, String? line)
        invalidLabel,
  }) {
    return notInstruction(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
  }) {
    return notInstruction?.call(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
    required TResult orElse(),
  }) {
    if (notInstruction != null) {
      return notInstruction(type, lineNumber, line);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(InvalidLabelFailure value) invalidLabel,
  }) {
    return notInstruction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
  }) {
    return notInstruction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
    required TResult orElse(),
  }) {
    if (notInstruction != null) {
      return notInstruction(this);
    }
    return orElse();
  }
}

abstract class NotInstructionFailure implements Failure {
  const factory NotInstructionFailure(
      {required NotInstructionType type,
      int? lineNumber,
      String? line}) = _$NotInstructionFailure;

  NotInstructionType get type => throw _privateConstructorUsedError;
  @override
  int? get lineNumber => throw _privateConstructorUsedError;
  @override
  String? get line => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $NotInstructionFailureCopyWith<NotInstructionFailure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidAInstructionValueFailureCopyWith<$Res>
    implements $FailureCopyWith<$Res> {
  factory $InvalidAInstructionValueFailureCopyWith(
          InvalidAInstructionValueFailure value,
          $Res Function(InvalidAInstructionValueFailure) then) =
      _$InvalidAInstructionValueFailureCopyWithImpl<$Res>;
  @override
  $Res call({InvalidAInstructionValueType type, int? lineNumber, String? line});
}

/// @nodoc
class _$InvalidAInstructionValueFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidAInstructionValueFailureCopyWith<$Res> {
  _$InvalidAInstructionValueFailureCopyWithImpl(
      InvalidAInstructionValueFailure _value,
      $Res Function(InvalidAInstructionValueFailure) _then)
      : super(_value, (v) => _then(v as InvalidAInstructionValueFailure));

  @override
  InvalidAInstructionValueFailure get _value =>
      super._value as InvalidAInstructionValueFailure;

  @override
  $Res call({
    Object? type = freezed,
    Object? lineNumber = freezed,
    Object? line = freezed,
  }) {
    return _then(InvalidAInstructionValueFailure(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as InvalidAInstructionValueType,
      lineNumber: lineNumber == freezed
          ? _value.lineNumber
          : lineNumber // ignore: cast_nullable_to_non_nullable
              as int?,
      line: line == freezed
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidAInstructionValueFailure
    implements InvalidAInstructionValueFailure {
  const _$InvalidAInstructionValueFailure(
      {required this.type, this.lineNumber, this.line});

  @override
  final InvalidAInstructionValueType type;
  @override
  final int? lineNumber;
  @override
  final String? line;

  @override
  String toString() {
    return 'Failure.invalidAInstructionValue(type: $type, lineNumber: $lineNumber, line: $line)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidAInstructionValueFailure &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.lineNumber, lineNumber) ||
                const DeepCollectionEquality()
                    .equals(other.lineNumber, lineNumber)) &&
            (identical(other.line, line) ||
                const DeepCollectionEquality().equals(other.line, line)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(lineNumber) ^
      const DeepCollectionEquality().hash(line);

  @JsonKey(ignore: true)
  @override
  $InvalidAInstructionValueFailureCopyWith<InvalidAInstructionValueFailure>
      get copyWith => _$InvalidAInstructionValueFailureCopyWithImpl<
          InvalidAInstructionValueFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            NotInstructionType type, int? lineNumber, String? line)
        notInstruction,
    required TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationType type,
            int? lineNumber, String? line)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationType type,
            int? lineNumber, String? line)
        invalidCInstructionComputation,
    required TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)
        invalidCInstructionJump,
    required TResult Function(
            InvalidFilePathType type, int? lineNumber, String? line)
        InvalidFilePath,
    required TResult Function(
            InvalidLabelType type, int? lineNumber, String? line)
        invalidLabel,
  }) {
    return invalidAInstructionValue(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
  }) {
    return invalidAInstructionValue?.call(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
    required TResult orElse(),
  }) {
    if (invalidAInstructionValue != null) {
      return invalidAInstructionValue(type, lineNumber, line);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(InvalidLabelFailure value) invalidLabel,
  }) {
    return invalidAInstructionValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
  }) {
    return invalidAInstructionValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
    required TResult orElse(),
  }) {
    if (invalidAInstructionValue != null) {
      return invalidAInstructionValue(this);
    }
    return orElse();
  }
}

abstract class InvalidAInstructionValueFailure implements Failure {
  const factory InvalidAInstructionValueFailure(
      {required InvalidAInstructionValueType type,
      int? lineNumber,
      String? line}) = _$InvalidAInstructionValueFailure;

  InvalidAInstructionValueType get type => throw _privateConstructorUsedError;
  @override
  int? get lineNumber => throw _privateConstructorUsedError;
  @override
  String? get line => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $InvalidAInstructionValueFailureCopyWith<InvalidAInstructionValueFailure>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidCInstructionDestinationFailureCopyWith<$Res>
    implements $FailureCopyWith<$Res> {
  factory $InvalidCInstructionDestinationFailureCopyWith(
          InvalidCInstructionDestinationFailure value,
          $Res Function(InvalidCInstructionDestinationFailure) then) =
      _$InvalidCInstructionDestinationFailureCopyWithImpl<$Res>;
  @override
  $Res call(
      {InvalidCInstructionDestinationType type, int? lineNumber, String? line});
}

/// @nodoc
class _$InvalidCInstructionDestinationFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidCInstructionDestinationFailureCopyWith<$Res> {
  _$InvalidCInstructionDestinationFailureCopyWithImpl(
      InvalidCInstructionDestinationFailure _value,
      $Res Function(InvalidCInstructionDestinationFailure) _then)
      : super(_value, (v) => _then(v as InvalidCInstructionDestinationFailure));

  @override
  InvalidCInstructionDestinationFailure get _value =>
      super._value as InvalidCInstructionDestinationFailure;

  @override
  $Res call({
    Object? type = freezed,
    Object? lineNumber = freezed,
    Object? line = freezed,
  }) {
    return _then(InvalidCInstructionDestinationFailure(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as InvalidCInstructionDestinationType,
      lineNumber: lineNumber == freezed
          ? _value.lineNumber
          : lineNumber // ignore: cast_nullable_to_non_nullable
              as int?,
      line: line == freezed
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidCInstructionDestinationFailure
    implements InvalidCInstructionDestinationFailure {
  const _$InvalidCInstructionDestinationFailure(
      {required this.type, this.lineNumber, this.line});

  @override
  final InvalidCInstructionDestinationType type;
  @override
  final int? lineNumber;
  @override
  final String? line;

  @override
  String toString() {
    return 'Failure.invalidCInstructionDestination(type: $type, lineNumber: $lineNumber, line: $line)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidCInstructionDestinationFailure &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.lineNumber, lineNumber) ||
                const DeepCollectionEquality()
                    .equals(other.lineNumber, lineNumber)) &&
            (identical(other.line, line) ||
                const DeepCollectionEquality().equals(other.line, line)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(lineNumber) ^
      const DeepCollectionEquality().hash(line);

  @JsonKey(ignore: true)
  @override
  $InvalidCInstructionDestinationFailureCopyWith<
          InvalidCInstructionDestinationFailure>
      get copyWith => _$InvalidCInstructionDestinationFailureCopyWithImpl<
          InvalidCInstructionDestinationFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            NotInstructionType type, int? lineNumber, String? line)
        notInstruction,
    required TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationType type,
            int? lineNumber, String? line)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationType type,
            int? lineNumber, String? line)
        invalidCInstructionComputation,
    required TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)
        invalidCInstructionJump,
    required TResult Function(
            InvalidFilePathType type, int? lineNumber, String? line)
        InvalidFilePath,
    required TResult Function(
            InvalidLabelType type, int? lineNumber, String? line)
        invalidLabel,
  }) {
    return invalidCInstructionDestination(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
  }) {
    return invalidCInstructionDestination?.call(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
    required TResult orElse(),
  }) {
    if (invalidCInstructionDestination != null) {
      return invalidCInstructionDestination(type, lineNumber, line);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(InvalidLabelFailure value) invalidLabel,
  }) {
    return invalidCInstructionDestination(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
  }) {
    return invalidCInstructionDestination?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
    required TResult orElse(),
  }) {
    if (invalidCInstructionDestination != null) {
      return invalidCInstructionDestination(this);
    }
    return orElse();
  }
}

abstract class InvalidCInstructionDestinationFailure implements Failure {
  const factory InvalidCInstructionDestinationFailure(
      {required InvalidCInstructionDestinationType type,
      int? lineNumber,
      String? line}) = _$InvalidCInstructionDestinationFailure;

  InvalidCInstructionDestinationType get type =>
      throw _privateConstructorUsedError;
  @override
  int? get lineNumber => throw _privateConstructorUsedError;
  @override
  String? get line => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $InvalidCInstructionDestinationFailureCopyWith<
          InvalidCInstructionDestinationFailure>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidCInstructionComputationFailureCopyWith<$Res>
    implements $FailureCopyWith<$Res> {
  factory $InvalidCInstructionComputationFailureCopyWith(
          InvalidCInstructionComputationFailure value,
          $Res Function(InvalidCInstructionComputationFailure) then) =
      _$InvalidCInstructionComputationFailureCopyWithImpl<$Res>;
  @override
  $Res call(
      {InvalidCInstructionComputationType type, int? lineNumber, String? line});
}

/// @nodoc
class _$InvalidCInstructionComputationFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidCInstructionComputationFailureCopyWith<$Res> {
  _$InvalidCInstructionComputationFailureCopyWithImpl(
      InvalidCInstructionComputationFailure _value,
      $Res Function(InvalidCInstructionComputationFailure) _then)
      : super(_value, (v) => _then(v as InvalidCInstructionComputationFailure));

  @override
  InvalidCInstructionComputationFailure get _value =>
      super._value as InvalidCInstructionComputationFailure;

  @override
  $Res call({
    Object? type = freezed,
    Object? lineNumber = freezed,
    Object? line = freezed,
  }) {
    return _then(InvalidCInstructionComputationFailure(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as InvalidCInstructionComputationType,
      lineNumber: lineNumber == freezed
          ? _value.lineNumber
          : lineNumber // ignore: cast_nullable_to_non_nullable
              as int?,
      line: line == freezed
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidCInstructionComputationFailure
    implements InvalidCInstructionComputationFailure {
  const _$InvalidCInstructionComputationFailure(
      {required this.type, this.lineNumber, this.line});

  @override
  final InvalidCInstructionComputationType type;
  @override
  final int? lineNumber;
  @override
  final String? line;

  @override
  String toString() {
    return 'Failure.invalidCInstructionComputation(type: $type, lineNumber: $lineNumber, line: $line)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidCInstructionComputationFailure &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.lineNumber, lineNumber) ||
                const DeepCollectionEquality()
                    .equals(other.lineNumber, lineNumber)) &&
            (identical(other.line, line) ||
                const DeepCollectionEquality().equals(other.line, line)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(lineNumber) ^
      const DeepCollectionEquality().hash(line);

  @JsonKey(ignore: true)
  @override
  $InvalidCInstructionComputationFailureCopyWith<
          InvalidCInstructionComputationFailure>
      get copyWith => _$InvalidCInstructionComputationFailureCopyWithImpl<
          InvalidCInstructionComputationFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            NotInstructionType type, int? lineNumber, String? line)
        notInstruction,
    required TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationType type,
            int? lineNumber, String? line)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationType type,
            int? lineNumber, String? line)
        invalidCInstructionComputation,
    required TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)
        invalidCInstructionJump,
    required TResult Function(
            InvalidFilePathType type, int? lineNumber, String? line)
        InvalidFilePath,
    required TResult Function(
            InvalidLabelType type, int? lineNumber, String? line)
        invalidLabel,
  }) {
    return invalidCInstructionComputation(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
  }) {
    return invalidCInstructionComputation?.call(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
    required TResult orElse(),
  }) {
    if (invalidCInstructionComputation != null) {
      return invalidCInstructionComputation(type, lineNumber, line);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(InvalidLabelFailure value) invalidLabel,
  }) {
    return invalidCInstructionComputation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
  }) {
    return invalidCInstructionComputation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
    required TResult orElse(),
  }) {
    if (invalidCInstructionComputation != null) {
      return invalidCInstructionComputation(this);
    }
    return orElse();
  }
}

abstract class InvalidCInstructionComputationFailure implements Failure {
  const factory InvalidCInstructionComputationFailure(
      {required InvalidCInstructionComputationType type,
      int? lineNumber,
      String? line}) = _$InvalidCInstructionComputationFailure;

  InvalidCInstructionComputationType get type =>
      throw _privateConstructorUsedError;
  @override
  int? get lineNumber => throw _privateConstructorUsedError;
  @override
  String? get line => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $InvalidCInstructionComputationFailureCopyWith<
          InvalidCInstructionComputationFailure>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidCInstructionJumpFailureCopyWith<$Res>
    implements $FailureCopyWith<$Res> {
  factory $InvalidCInstructionJumpFailureCopyWith(
          InvalidCInstructionJumpFailure value,
          $Res Function(InvalidCInstructionJumpFailure) then) =
      _$InvalidCInstructionJumpFailureCopyWithImpl<$Res>;
  @override
  $Res call({InvalidCInstructionJumpType type, int? lineNumber, String? line});
}

/// @nodoc
class _$InvalidCInstructionJumpFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidCInstructionJumpFailureCopyWith<$Res> {
  _$InvalidCInstructionJumpFailureCopyWithImpl(
      InvalidCInstructionJumpFailure _value,
      $Res Function(InvalidCInstructionJumpFailure) _then)
      : super(_value, (v) => _then(v as InvalidCInstructionJumpFailure));

  @override
  InvalidCInstructionJumpFailure get _value =>
      super._value as InvalidCInstructionJumpFailure;

  @override
  $Res call({
    Object? type = freezed,
    Object? lineNumber = freezed,
    Object? line = freezed,
  }) {
    return _then(InvalidCInstructionJumpFailure(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as InvalidCInstructionJumpType,
      lineNumber: lineNumber == freezed
          ? _value.lineNumber
          : lineNumber // ignore: cast_nullable_to_non_nullable
              as int?,
      line: line == freezed
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidCInstructionJumpFailure
    implements InvalidCInstructionJumpFailure {
  const _$InvalidCInstructionJumpFailure(
      {required this.type, this.lineNumber, this.line});

  @override
  final InvalidCInstructionJumpType type;
  @override
  final int? lineNumber;
  @override
  final String? line;

  @override
  String toString() {
    return 'Failure.invalidCInstructionJump(type: $type, lineNumber: $lineNumber, line: $line)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidCInstructionJumpFailure &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.lineNumber, lineNumber) ||
                const DeepCollectionEquality()
                    .equals(other.lineNumber, lineNumber)) &&
            (identical(other.line, line) ||
                const DeepCollectionEquality().equals(other.line, line)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(lineNumber) ^
      const DeepCollectionEquality().hash(line);

  @JsonKey(ignore: true)
  @override
  $InvalidCInstructionJumpFailureCopyWith<InvalidCInstructionJumpFailure>
      get copyWith => _$InvalidCInstructionJumpFailureCopyWithImpl<
          InvalidCInstructionJumpFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            NotInstructionType type, int? lineNumber, String? line)
        notInstruction,
    required TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationType type,
            int? lineNumber, String? line)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationType type,
            int? lineNumber, String? line)
        invalidCInstructionComputation,
    required TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)
        invalidCInstructionJump,
    required TResult Function(
            InvalidFilePathType type, int? lineNumber, String? line)
        InvalidFilePath,
    required TResult Function(
            InvalidLabelType type, int? lineNumber, String? line)
        invalidLabel,
  }) {
    return invalidCInstructionJump(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
  }) {
    return invalidCInstructionJump?.call(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
    required TResult orElse(),
  }) {
    if (invalidCInstructionJump != null) {
      return invalidCInstructionJump(type, lineNumber, line);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(InvalidLabelFailure value) invalidLabel,
  }) {
    return invalidCInstructionJump(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
  }) {
    return invalidCInstructionJump?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
    required TResult orElse(),
  }) {
    if (invalidCInstructionJump != null) {
      return invalidCInstructionJump(this);
    }
    return orElse();
  }
}

abstract class InvalidCInstructionJumpFailure implements Failure {
  const factory InvalidCInstructionJumpFailure(
      {required InvalidCInstructionJumpType type,
      int? lineNumber,
      String? line}) = _$InvalidCInstructionJumpFailure;

  InvalidCInstructionJumpType get type => throw _privateConstructorUsedError;
  @override
  int? get lineNumber => throw _privateConstructorUsedError;
  @override
  String? get line => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $InvalidCInstructionJumpFailureCopyWith<InvalidCInstructionJumpFailure>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidFilePathFailureCopyWith<$Res>
    implements $FailureCopyWith<$Res> {
  factory $InvalidFilePathFailureCopyWith(InvalidFilePathFailure value,
          $Res Function(InvalidFilePathFailure) then) =
      _$InvalidFilePathFailureCopyWithImpl<$Res>;
  @override
  $Res call({InvalidFilePathType type, int? lineNumber, String? line});
}

/// @nodoc
class _$InvalidFilePathFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidFilePathFailureCopyWith<$Res> {
  _$InvalidFilePathFailureCopyWithImpl(InvalidFilePathFailure _value,
      $Res Function(InvalidFilePathFailure) _then)
      : super(_value, (v) => _then(v as InvalidFilePathFailure));

  @override
  InvalidFilePathFailure get _value => super._value as InvalidFilePathFailure;

  @override
  $Res call({
    Object? type = freezed,
    Object? lineNumber = freezed,
    Object? line = freezed,
  }) {
    return _then(InvalidFilePathFailure(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as InvalidFilePathType,
      lineNumber: lineNumber == freezed
          ? _value.lineNumber
          : lineNumber // ignore: cast_nullable_to_non_nullable
              as int?,
      line: line == freezed
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidFilePathFailure implements InvalidFilePathFailure {
  const _$InvalidFilePathFailure(
      {required this.type, this.lineNumber, this.line});

  @override
  final InvalidFilePathType type;
  @override
  final int? lineNumber;
  @override
  final String? line;

  @override
  String toString() {
    return 'Failure.InvalidFilePath(type: $type, lineNumber: $lineNumber, line: $line)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidFilePathFailure &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.lineNumber, lineNumber) ||
                const DeepCollectionEquality()
                    .equals(other.lineNumber, lineNumber)) &&
            (identical(other.line, line) ||
                const DeepCollectionEquality().equals(other.line, line)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(lineNumber) ^
      const DeepCollectionEquality().hash(line);

  @JsonKey(ignore: true)
  @override
  $InvalidFilePathFailureCopyWith<InvalidFilePathFailure> get copyWith =>
      _$InvalidFilePathFailureCopyWithImpl<InvalidFilePathFailure>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            NotInstructionType type, int? lineNumber, String? line)
        notInstruction,
    required TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationType type,
            int? lineNumber, String? line)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationType type,
            int? lineNumber, String? line)
        invalidCInstructionComputation,
    required TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)
        invalidCInstructionJump,
    required TResult Function(
            InvalidFilePathType type, int? lineNumber, String? line)
        InvalidFilePath,
    required TResult Function(
            InvalidLabelType type, int? lineNumber, String? line)
        invalidLabel,
  }) {
    return InvalidFilePath(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
  }) {
    return InvalidFilePath?.call(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
    required TResult orElse(),
  }) {
    if (InvalidFilePath != null) {
      return InvalidFilePath(type, lineNumber, line);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(InvalidLabelFailure value) invalidLabel,
  }) {
    return InvalidFilePath(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
  }) {
    return InvalidFilePath?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
    required TResult orElse(),
  }) {
    if (InvalidFilePath != null) {
      return InvalidFilePath(this);
    }
    return orElse();
  }
}

abstract class InvalidFilePathFailure implements Failure {
  const factory InvalidFilePathFailure(
      {required InvalidFilePathType type,
      int? lineNumber,
      String? line}) = _$InvalidFilePathFailure;

  InvalidFilePathType get type => throw _privateConstructorUsedError;
  @override
  int? get lineNumber => throw _privateConstructorUsedError;
  @override
  String? get line => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $InvalidFilePathFailureCopyWith<InvalidFilePathFailure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidLabelFailureCopyWith<$Res>
    implements $FailureCopyWith<$Res> {
  factory $InvalidLabelFailureCopyWith(
          InvalidLabelFailure value, $Res Function(InvalidLabelFailure) then) =
      _$InvalidLabelFailureCopyWithImpl<$Res>;
  @override
  $Res call({InvalidLabelType type, int? lineNumber, String? line});
}

/// @nodoc
class _$InvalidLabelFailureCopyWithImpl<$Res>
    extends _$FailureCopyWithImpl<$Res>
    implements $InvalidLabelFailureCopyWith<$Res> {
  _$InvalidLabelFailureCopyWithImpl(
      InvalidLabelFailure _value, $Res Function(InvalidLabelFailure) _then)
      : super(_value, (v) => _then(v as InvalidLabelFailure));

  @override
  InvalidLabelFailure get _value => super._value as InvalidLabelFailure;

  @override
  $Res call({
    Object? type = freezed,
    Object? lineNumber = freezed,
    Object? line = freezed,
  }) {
    return _then(InvalidLabelFailure(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as InvalidLabelType,
      lineNumber: lineNumber == freezed
          ? _value.lineNumber
          : lineNumber // ignore: cast_nullable_to_non_nullable
              as int?,
      line: line == freezed
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$InvalidLabelFailure implements InvalidLabelFailure {
  const _$InvalidLabelFailure({required this.type, this.lineNumber, this.line});

  @override
  final InvalidLabelType type;
  @override
  final int? lineNumber;
  @override
  final String? line;

  @override
  String toString() {
    return 'Failure.invalidLabel(type: $type, lineNumber: $lineNumber, line: $line)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidLabelFailure &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.lineNumber, lineNumber) ||
                const DeepCollectionEquality()
                    .equals(other.lineNumber, lineNumber)) &&
            (identical(other.line, line) ||
                const DeepCollectionEquality().equals(other.line, line)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(lineNumber) ^
      const DeepCollectionEquality().hash(line);

  @JsonKey(ignore: true)
  @override
  $InvalidLabelFailureCopyWith<InvalidLabelFailure> get copyWith =>
      _$InvalidLabelFailureCopyWithImpl<InvalidLabelFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            NotInstructionType type, int? lineNumber, String? line)
        notInstruction,
    required TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationType type,
            int? lineNumber, String? line)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationType type,
            int? lineNumber, String? line)
        invalidCInstructionComputation,
    required TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)
        invalidCInstructionJump,
    required TResult Function(
            InvalidFilePathType type, int? lineNumber, String? line)
        InvalidFilePath,
    required TResult Function(
            InvalidLabelType type, int? lineNumber, String? line)
        invalidLabel,
  }) {
    return invalidLabel(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
  }) {
    return invalidLabel?.call(type, lineNumber, line);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(NotInstructionType type, int? lineNumber, String? line)?
        notInstruction,
    TResult Function(
            InvalidAInstructionValueType type, int? lineNumber, String? line)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationType type, int? lineNumber,
            String? line)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationType type, int? lineNumber,
            String? line)?
        invalidCInstructionComputation,
    TResult Function(
            InvalidCInstructionJumpType type, int? lineNumber, String? line)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathType type, int? lineNumber, String? line)?
        InvalidFilePath,
    TResult Function(InvalidLabelType type, int? lineNumber, String? line)?
        invalidLabel,
    required TResult orElse(),
  }) {
    if (invalidLabel != null) {
      return invalidLabel(type, lineNumber, line);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotInstructionFailure value) notInstruction,
    required TResult Function(InvalidAInstructionValueFailure value)
        invalidAInstructionValue,
    required TResult Function(InvalidCInstructionDestinationFailure value)
        invalidCInstructionDestination,
    required TResult Function(InvalidCInstructionComputationFailure value)
        invalidCInstructionComputation,
    required TResult Function(InvalidCInstructionJumpFailure value)
        invalidCInstructionJump,
    required TResult Function(InvalidFilePathFailure value) InvalidFilePath,
    required TResult Function(InvalidLabelFailure value) invalidLabel,
  }) {
    return invalidLabel(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
  }) {
    return invalidLabel?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotInstructionFailure value)? notInstruction,
    TResult Function(InvalidAInstructionValueFailure value)?
        invalidAInstructionValue,
    TResult Function(InvalidCInstructionDestinationFailure value)?
        invalidCInstructionDestination,
    TResult Function(InvalidCInstructionComputationFailure value)?
        invalidCInstructionComputation,
    TResult Function(InvalidCInstructionJumpFailure value)?
        invalidCInstructionJump,
    TResult Function(InvalidFilePathFailure value)? InvalidFilePath,
    TResult Function(InvalidLabelFailure value)? invalidLabel,
    required TResult orElse(),
  }) {
    if (invalidLabel != null) {
      return invalidLabel(this);
    }
    return orElse();
  }
}

abstract class InvalidLabelFailure implements Failure {
  const factory InvalidLabelFailure(
      {required InvalidLabelType type,
      int? lineNumber,
      String? line}) = _$InvalidLabelFailure;

  InvalidLabelType get type => throw _privateConstructorUsedError;
  @override
  int? get lineNumber => throw _privateConstructorUsedError;
  @override
  String? get line => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  $InvalidLabelFailureCopyWith<InvalidLabelFailure> get copyWith =>
      throw _privateConstructorUsedError;
}
